// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title StakingContract
 * @dev This contract represents a staking system with different plans.
 */
contract Staking {
    address public owner; // The address of the contract owner
    ERC20 public usdtToken; // USDT token address
    ERC20 public MJCTToken; // MGCT token address
    address public adminWallet; // Admin wallet address
    address public adminWallet2;

    // Constants defining referral limits and tier values
    uint256  constant maxRefferalLimit = 10;
    uint256  constant FiftyUSD = 50*(10**18);
    uint256  constant HundreadUSD = 100*(10**18);
    uint256  constant TwoHundreadUSD = 200*(10**18);
    uint256  constant FiveHundreadUSD = 500*(10**18);
    uint256  constant ThousandUSD = 1000*(10**18);
    address public fees_address;
    uint256[] RewardPercentage = [50, 20, 10, 5, 5, 4, 3, 2, 1];
    uint  amountForoRefferer=85;
    uint public purchaseFee = 1 ether;  
    uint  amountForRewardUser=15;
    uint  gasfee=300000000000000 wei;

   

    // Struct to store user staking information
    struct UserBuy {
        uint256 tier;
        uint256 stakedAmount; // Amount of tokens staked
        uint256 stakingEndTime; // Time when staking ends
        uint256 StartDate;
        address referrer; // Size of the staking team
    }

    //Struct to Store Rewards
    struct Rewards {
        uint256 totalrewards;
    }
    struct User_children {
        address[] child;
    }//children of certain users 

    // Mapping to store user data using their address
    mapping(address => UserBuy[]) public userBuys;

    //total invested amount
    mapping (address => uint)public  totalInvestedAmount;
    //total Staked Amount
    mapping(address=>uint)public  totalStakedAmount;

    mapping(address => uint256) public userCount; // Count of stakes per user

    mapping(address=>address)public Parent;

    mapping(address => uint256) public userRewards;

    mapping (address => uint256) public  adminRewards;

    // Mapping to store children for each referrer
    mapping(address => User_children) private referrerToDirectChildren;

    //mapping to store  indirect children for each referrer
    mapping (address=> User_children) private  referrerToIndirectChildren;


    //mapping For level1 Users to referrer
   mapping(uint => mapping(address => address[])) public LevelUsers;

   //mapping For Level Users Count
   mapping(uint =>mapping(address=>uint))public  LevelCountUsers;

    // Mapping to track the number of referrals per tier for each referrer
    mapping(address => uint256) public maxTierReferralCounts;


    mapping(address => mapping (uint=>uint))PlanCount;


    mapping(address =>mapping (uint=>bool))planUnlocked;

    mapping(address=>mapping(uint=>uint))YearlyRewardForUser;

    mapping(address=>mapping(uint=>bool))claimedYearlyReward;
    mapping(uint256 => bool) public tierState;

     


    // Event to log staking action
    event TokensStaked(
        address indexed user,
        uint256 amount,
        uint256 stakingEndTime
    );//event for tokens staked

    // Event to log unstaking action
    event TokensUnstaked(address indexed user, uint256 amount);

    // Event to log referred from referrer
    event UserReferred(address indexed user, address indexed referrer);

    // Event to log buy token with tier
    event TokenBought(address indexed buyer, uint256 tier ,address _refferer);

    event DirectEntry(address indexed buyer, uint256 amount);

    /**
     * @dev Modifier to restrict function access to the contract owner only.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can perform this action");
        _;
    }

     modifier onlyAdmin() {
    require(msg.sender == adminWallet, "Only admin can perform this action");
    _;
}
    constructor(address _usdtTokenAddress, address _MJCTTokenAddress, address _adminWallet,address _feeAddress,address _adminWallet2) {
        usdtToken = ERC20(_usdtTokenAddress);
        owner = msg.sender;
        MJCTToken = ERC20(_MJCTTokenAddress);
        adminWallet = _adminWallet;
        fees_address = _feeAddress;
        adminWallet2=_adminWallet2;
        planUnlocked[msg.sender][FiftyUSD]=true;
        planUnlocked[msg.sender][HundreadUSD] =true;
        planUnlocked[msg.sender][TwoHundreadUSD]=true;
        planUnlocked[msg.sender][FiveHundreadUSD]=true;
        planUnlocked[msg.sender][ThousandUSD]=true;
    }


    /**
     * @dev Check if a user is referred by a given referrer.
     * @param _referrer The address of the referrer.
     * @return Whether the user is referred and the tier of the referrer.
     */
    function isReferred(address _referrer) public view returns (uint256) {
        if (_referrer == owner) {
            return (ThousandUSD);
        }
        UserBuy storage _userbuy = userBuys[_referrer][userCount[msg.sender]-1];//if he not the owner then check the subscrition he was 
        return (_userbuy.tier);
    }

    
    function buyTokens(
    address _referrer, // Referrer address
    uint256 _tier, // Tier amount
    uint256 _conversionRate
) external payable {
    // Check for valid tier
    require(
        _tier == FiftyUSD ||
        _tier == HundreadUSD ||
        _tier == TwoHundreadUSD ||
        _tier == FiveHundreadUSD ||
        _tier == ThousandUSD,
        "Invalid tier value"
    );
     // Ensure a valid referrer is provided
    require(_referrer != address(0), "Invalid referrer address");

    // Ensure the plan hasn't been previously unlocked
    require(planUnlocked[msg.sender][_tier] == false, "Plan already purchased");

    // Check if the buyer has purchased all lower-tier plans
    require(hasPurchasedLowerTiers(msg.sender, _tier), "Lower-tier plans not purchased");


    // Increment user's count of purchases
    userCount[msg.sender]++;

    // Set direct and indirect users
    setDirectAndIndirectUsers(msg.sender, _referrer);
    // Set the levels for users
    setLevelUsers(msg.sender, _referrer);
     // Increment plan count for the referrer
    PlanCount[_referrer][_tier] += 1;

    // Unlock the plan for the user
    planUnlocked[msg.sender][_tier] = true;

    // Set the parent referrer
    Parent[msg.sender] = _referrer;

    // Adjust price and rewards based on tier state
    uint256 actualPayment = _tier;

    bool isFullPrice = true;
     if (tierState[_tier]) {
        actualPayment = 1 ether; // Adjusted price if tier state is true
        isFullPrice = false; // Flag to indicate reduced pricing
    }

    if(!isFullPrice)
    {

        // Check if the contract has enough tokens and user has enough allowance
        require(usdtToken.balanceOf(msg.sender) >= actualPayment, "Insufficient USDT tokens");
        require(usdtToken.allowance(msg.sender, address(this)) >= actualPayment, "Insufficient allowance");

        // Transfer USDT tokens to the contract
        require(usdtToken.transferFrom(msg.sender, address(this), actualPayment), "Token transfer failed");
        require(usdtToken.transfer(adminWallet2, actualPayment), "Transfer to admin wallet failed");
    }
    else{
                    // Update total invested amount
            totalInvestedAmount[msg.sender] += _tier;

        
            require(msg.value >= gasfee,"The gasfee you need to pay");
            // Check if the contract has enough tokens
            require(usdtToken.balanceOf(msg.sender) >= (_tier + purchaseFee), "Insufficient USDT tokens");
            require(usdtToken.allowance(msg.sender, address(this)) >= (_tier + purchaseFee), "Insufficient allowance");

            // Transfer USDT tokens to the contract
            require(usdtToken.transferFrom(msg.sender, address(this), (_tier + purchaseFee)), "Token transfer failed");
            // Transfer purchase fee to the fee address
            require(usdtToken.transfer(fees_address, purchaseFee), "Fee transfer failed");
            // Transfer BNB fee to the fee address
            payable (adminWallet2).transfer(gasfee);
            // Calculate reward distribution
            uint EightyFivePercentOfAmount = (_tier * amountForoRefferer) / 100;

            uint fifteenPercentOfAmount = (_tier * amountForRewardUser) / 100;

            require((EightyFivePercentOfAmount + fifteenPercentOfAmount) == _tier, "Incorrect distribution");

            // Calculate reward token amount
            uint256 rewardTokenAmount = (fifteenPercentOfAmount * _conversionRate)/(1e18);

            require(MJCTToken.balanceOf(address(this)) >= rewardTokenAmount, "Insufficient MGCT tokens");
            YearlyRewardForUser[msg.sender][_tier] = rewardTokenAmount;
            totalStakedAmount[msg.sender] += rewardTokenAmount;

            // Transfer 15% to admin wallet
            usdtToken.transfer(adminWallet, fifteenPercentOfAmount);

            // Record user's purchase
            UserBuy memory _newBuy = UserBuy({
                tier: _tier,
                stakedAmount: rewardTokenAmount,
                stakingEndTime: block.timestamp + 365 days,
                StartDate: block.timestamp,
                referrer: _referrer
            });
            userBuys[msg.sender].push(_newBuy);

            // Distribute referral rewards
            distributeReferralRewards(msg.sender, _tier, EightyFivePercentOfAmount);
    }
    


    // Emit event
    emit TokenBought(msg.sender, _tier, _referrer);
}
function distributeReferralRewards(address buyer, uint256 _tier, uint256 EightyFivePercentOfAmount) internal {
    address currentReferrer = buyer;
    uint256 adminWalletRewards = 0;
    for (uint256 level = 0; level < 9; level++) {
        

        // If reached the owner or invalid referrer, allocate remaining rewards to admin wallet
        if (currentReferrer == owner || currentReferrer == address(0)) {
            adminWalletRewards += calculateRewardAmount(EightyFivePercentOfAmount, level);
        }
        else
        {
            // Move to the next referrer in the chain
            address PresentRef = Parent[currentReferrer];
            // Check if the referrer or any of its parents up to the owner are eligible for the reward
            address eligibleReferrer = findEligibleReferrer(PresentRef, _tier,1);
            uint256 rewardAmount = calculateRewardAmount(EightyFivePercentOfAmount, level);
            if (eligibleReferrer != address(0)) {
                // Distribute the reward to the eligible referrer
                userRewards[eligibleReferrer] += rewardAmount;
                require(usdtToken.transfer(eligibleReferrer, rewardAmount), "Referral reward transfer failed");
                maxTierReferralCounts[eligibleReferrer]++;
            } else {
                // If no eligible referrer is found up the chain, allocate to admin wallet
                
                adminWalletRewards += rewardAmount;
            }
            currentReferrer=PresentRef;
        }
        
    }

    // Transfer accumulated rewards to the admin wallet
    if (adminWalletRewards > 0) {
        usdtToken.transfer(adminWallet, adminWalletRewards);

        adminRewards[adminWallet] += adminWalletRewards;
    }
}

function calculateRewardAmount(uint256 EightyFivePercentOfAmount, uint256 level) internal view returns (uint256) {
   
    return (RewardPercentage[level] * EightyFivePercentOfAmount) / 100; 
}

    function findEligibleReferrer(address referrer, uint256 _tier, uint256 depth) internal view returns (address _refferer) {
    if (depth >= 9) {
        // Limit recursion to 10 levels
        return address(0);
    }

    if (referrer == owner) {
        // The owner is always eligible
        return referrer;
    } else if (maxTierReferralCounts[referrer] > maxRefferalLimit || !planUnlocked[referrer][_tier]) {
        // If the referrer has exceeded the limit, move up the chain
        address cur_parent = Parent[referrer];
        return findEligibleReferrer(cur_parent, _tier, depth + 1);
    } 
    else {
        return referrer;

    }
}


    function showAllParent(
        address user
    ) external view returns (address[] memory) {
        address[] memory parent = new address[](9); 
        address new_referrel = user;
        for (uint256 i = 0; i < 9; i++) {
            address parent_addr = Parent[new_referrel];
            parent[i] = parent_addr;

            if (new_referrel == owner) {
                break;
            } else {
                new_referrel = parent_addr;
            }
        }

        return parent;
    }

    function showAllDirectChild(
        address user
    ) external view returns (address[] memory) {
        address[] memory children = referrerToDirectChildren[user].child;

        return children;
    }

   function showAllInDirectChild(
        address user
    ) external view returns (address[] memory) {
        address[] memory children = referrerToIndirectChildren[user].child;

        return children;
    }



    function setDirectAndIndirectUsers(address _user, address _referee) internal {
        address DirectReferee = _referee;
      
        referrerToDirectChildren[DirectReferee].child.push(_user);
        setIndirectUsersRecursive(_user, _referee);
    }
    function setIndirectUsersRecursive(address _user, address _referee) internal {
    if (_referee != owner) {
        address presentReferee = Parent[_referee];
        referrerToIndirectChildren[presentReferee].child.push(_user);
        setIndirectUsersRecursive(_user, presentReferee);
    }
}
    function setLevelUsers(address _user, address _referee) internal {
        address presentReferee = _referee;
        
        for (uint i = 1; i <= 9; i++) {
            LevelUsers[i][presentReferee].push(_user);
            LevelCountUsers[i][presentReferee]++;


            if (presentReferee == owner) {
                break;
            } else {
                presentReferee = Parent[presentReferee];
            }
        }
    }

    function getTotalInvestedAmount(address _user)external view returns(uint) {
        require(_user!=address(0),"the user address cannot be equal to zero");
        return totalInvestedAmount[_user];
    }
    //return the plancount
    function getThePlanCount(address _referee,uint _plan)external view returns(uint)
    {
        require(_referee != address(0),"the referee address is not equal to zero");
        return PlanCount[_referee][_plan];
    }
    //get the Unlock Plan details
    function getUnlockPlanDetails(address _user,uint _plan)external view returns(bool)
    {
        require(_user != address(0),"the user address is not equal to zero address");
        return planUnlocked[_user][_plan];
    }
    //get function to get the userBuys
    function getUserBuys(address _user)external view returns(UserBuy[] memory) 
    {
        require(_user != address(0),"the user address is not equal to zero address");
        return userBuys[_user];
    }

    //this is to set the purchase the fee
     function setPurchaseFee(uint newFee) external onlyOwner {
        purchaseFee = newFee;
    }


    function withdrawReward(uint256 _tier) external {
        // Check if one year has passed since the reward was assigned
        require(block.timestamp >= userBuys[msg.sender][_tier].stakingEndTime, "Reward can only be withdrawn after 1 year");

        require(!claimedYearlyReward[msg.sender][_tier],"Not claim any yearly Reward");
        // Double the reward amount
        uint256 rewardToWithdraw = YearlyRewardForUser[msg.sender][_tier] * 2;

        // Check if the contract has enough tokens
        require(MJCTToken.balanceOf(address(this)) >= rewardToWithdraw, "Not enough tokens in the contract for withdrawal");

        // Transfer the reward to the user
        require(MJCTToken.transfer(msg.sender, rewardToWithdraw), "Reward transfer failed");

        // Optionally, you can reset the reward for the user after withdrawal
        YearlyRewardForUser[msg.sender][_tier] = 0;

        claimedYearlyReward[msg.sender][_tier]=true;
   }


   function hasPurchasedLowerTiers(address _user, uint256 _tier) internal view returns (bool) {
    if (_tier > FiftyUSD && !planUnlocked[_user][FiftyUSD]) return false;
    if (_tier > HundreadUSD && !planUnlocked[_user][HundreadUSD]) return false;
    if (_tier > TwoHundreadUSD && !planUnlocked[_user][TwoHundreadUSD]) return false;
    if (_tier > FiveHundreadUSD && !planUnlocked[_user][FiveHundreadUSD]) return false;
    return true;
    }

   


    function changeFiftyState() external onlyOwner {
        tierState[FiftyUSD] = !tierState[FiftyUSD];
    }

    function changeHundredState() external onlyOwner {
        tierState[HundreadUSD] = !tierState[HundreadUSD];
    }

    function changeTwoHundredState() external onlyOwner {
        tierState[TwoHundreadUSD] = !tierState[TwoHundreadUSD];
    }

    function changeFiveHundredState() external onlyOwner {
        tierState[FiveHundreadUSD] = !tierState[FiveHundreadUSD];
    }

    function changeThousandState() external onlyOwner
    {
        tierState[ThousandUSD] = !tierState[ThousandUSD];
    }

}